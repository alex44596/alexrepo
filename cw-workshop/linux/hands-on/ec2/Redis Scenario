# REDIS

Redis is an in-memory key-value store known for its flexibility, performance, and wide language support. It can be used as used as a database, cache and message broker as well as session engine.


#Step 1 — Installing and Configuring Redis

Lets first install the GCC compiler for our server.

```bash
sudo yum -y install gcc make
```

output

```bash
[ec2-user@ip-172-31-2-38 ~]$ sudo yum -y install gcc make
Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
Package 1:make-3.82-24.amzn2.x86_64 already installed and latest version
Resolving Dependencies
--> Running transaction check
---> Package gcc.x86_64 0:7.3.1-6.amzn2.0.4 will be installed
--> Processing Dependency: cpp = 7.3.1-6.amzn2.0.4 for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: glibc-devel >= 2.2.90-12 for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libubsan.so.0()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libtsan.so.0()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libquadmath.so.0()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libmpxwrappers.so.2()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libmpx.so.2()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libmpfr.so.4()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libmpc.so.3()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: liblsan.so.0()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libitm.so.1()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libcilkrts.so.5()(64bit) for package: gcc-7.3.1-6.amzn2.0.4.x86_64
--> Processing Dependency: libatomic.so.1()(64bit) for package: gc
*
*
*
```
For the following steps open the ** cd /usr/local/src ** folder

```bash
cd /usr/local/src
```
Here we can download the stable version for the redis server

```bash
sudo wget http://download.redis.io/redis-stable.tar.gz
```

Output

```bash
[ec2-user@ip-172-31-2-38 src]$ sudo wget http://download.redis.io/redis-stable.tar.gz
--2020-06-30 17:44:32--  http://download.redis.io/redis-stable.tar.gz
Resolving download.redis.io (download.redis.io)... 45.60.121.1
Connecting to download.redis.io (download.redis.io)|45.60.121.1|:80... connected.
HTTP request sent, awaiting response... 301 Moved Permanently
Location: https://download.redis.io/redis-stable.tar.gz [following]
--2020-06-30 17:44:32--  https://download.redis.io/redis-stable.tar.gz
Connecting to download.redis.io (download.redis.io)|45.60.121.1|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2261060 (2.2M) [application/octet-stream]
Saving to: ‘redis-stable.tar.gz’

100%[============================================================================================================================================================================================================================>] 2,261,060   --.-K/s   in 0.1s 
```

Now we can extract the tar file

```bash
sudo tar xvzf redis-stable.tar.gz
```

Since we alredy got what we needed from the zipped file now we can remove it.

```bash
sudo rm -f redis-stable.tar.gz
```

as you may notice with the ls command we have the redis stable version

Output
```bash
[ec2-user@ip-172-31-2-38 src]$ ls
redis-stable
```

Lets open this up

```bash
cd redis-stable
```

Here we can use the  **make distclean** command. It basically ‘distclean’ deletes all files in the current directory that are created by configuring or building the program.Since have unpacked the source and built the program without creating any other files, ‘make distclean’ should leave only the files that were in the distribution

```bash
sudo make distclean
```

Output

```bash
[ec2-user@ip-172-31-2-38 redis-stable]$ sudo make distclean
cd src && make distclean
make[1]: Entering directory `/usr/local/src/redis-stable/src'
rm -rf redis-server redis-sentinel redis-cli redis-benchmark redis-check-rdb redis-check-aof *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark
rm -f adlist.d quicklist.d ae.d anet.d dict.d server.d sds.d zmalloc.d lzf_c.d lzf_d.d pqsort.d zipmap.d sha1.d ziplist.d release.d networking.d util.d object.d db.d replication.d rdb.d t_string.d t_list.d t_set.d t_zset.d t_hash.d config.d aof.d pubsub.d multi.d debug.d sort.d intset.d syncio.d cluster.d crc16.d endianconv.d slowlog.d scripting.d bio.d rio.d rand.d memtest.d crcspeed.d crc64.d bitops.d sentinel.d notify.d setproctitle.d blocked.d hyperloglog.d latency.d sparkline.d redis-check-rdb.d redis-check-aof.d 
geo.d lazyfree.d module.d evict.d expire.d geohash.d geohash_helper.d childinfo.d defrag.d siphash.d rax.d t_stream.d listpack.d localtime.d lolwut.d lolwut5.d lolwut6.d acl.d gopher.d tracking.d connection.d tls.d sha256.d timeout.d setcpuaffinity.d anet.d adlist.d dict.d redis-cli.d zmalloc.d release.d ae.d crcspeed.d crc64.d siphash.d crc16.d ae.d anet.d redis-benchmark.d adlist.d dict.d zmalloc.d siphash.d
(cd ../deps && make distclean)
make[2]: Entering directory `/usr/local/src/redis-stable/deps'
(cd hiredis && make clean) > /dev/null || true
(cd linenoise && make clean) > /dev/null || true
(cd lua && make clean) > /dev/null || true
(cd jemalloc && [ -f Makefile ] && make distclean) > /dev/null || true
(rm -f .make-*)
make[2]: Leaving directory `/usr/local/src/redis-stable/deps'
(rm -f .make-*)
make[1]: Leaving directory `/usr/local/src/redis-stable/src'
```

Now we can run the **sudo make** command to install. Sudo make lets you install the files in directories which are otherwise read-only to you as a user

```bash
sudo make
```

We need to download TCL script as a dependency.TCL is shell application that reads TCL command from its standard input or from a file and gives desired results.

```
sudo yum install -y tcl
```

**Now we are ready to make a test!!!**

```bash
sudo make test
```

Output -- A lot of okays. It is taking time...

```bash
[ok]: CLIENT SETNAME can change the name of an existing connection
[ok]: After CLIENT SETNAME, connection can still be closed
[ok]: CONFIG sanity
[ok]: SORT speed, 100 element list BY key, 100 times
[ok]: SORT speed, 100 element list BY hash field, 100 times
[ok]: Slave should be able to synchronize with the master
'
'
[46/54 done]: integration/replication-3 (173 seconds
'
'
```

YAAY! Finally you should get the smiling face for the all tests that passed.

```bash

                   The End

Execution time of different units:
  1 seconds - unit/type/incr
  1 seconds - unit/printver
  1 seconds - unit/auth
  2 seconds - unit/keyspace
  3 seconds - unit/protocol
  1 seconds - unit/quit
  3 seconds - unit/multi
  1 seconds - unit/acl
  6 seconds - unit/type/stream-cgroups
  16 seconds - unit/type/list
  16 seconds - unit/expire
  28 seconds - integration/block-repl
  34 seconds - unit/scan
  35 seconds - unit/type/hash
  41 seconds - unit/other
  47 seconds - unit/type/string
  2 seconds - integration/convert-zipmap-hash-on-load
  1 seconds - integration/logging
  17 seconds - integration/aof
  52 seconds - unit/type/set
  22 seconds - integration/rdb
  1 seconds - unit/pubsub
  3 seconds - unit/slowlog
  68 seconds - unit/type/zset
  23 seconds - integration/psync2-reg
  2 seconds - unit/introspection
  76 seconds - unit/sort
  2 seconds - unit/limits
  29 seconds - integration/psync2-pingoff
  82 seconds - unit/dump
  6 seconds - unit/introspection-2
  81 seconds - unit/aofrw
  19 seconds - unit/scripting
  72 seconds - integration/replication-2
  9 seconds - unit/bitfield
  9 seconds - unit/lazyfree
  8 seconds - unit/wait
  1 seconds - unit/tls
  52 seconds - integration/psync2
  2 seconds - unit/tracking
  28 seconds - unit/bitops
  41 seconds - unit/memefficiency
  133 seconds - unit/type/list-2
  53 seconds - unit/pendingquerybuf
  168 seconds - unit/type/list-3
  173 seconds - integration/replication-3
  159 seconds - integration/replication-4
  142 seconds - unit/hyperloglog
  243 seconds - unit/type/stream
  233 seconds - integration/replication-psync
  191 seconds - unit/geo
  241 seconds - unit/maxmemory
  270 seconds - unit/obuf-limits
  352 seconds - integration/replication
  91 seconds - defrag

\o/ All tests passed without errors!
```

Now we need to copy the Command line interfaces and the Redis server Executables to our local bin folder. This is a proper place.

```bash
sudo cp src/redis-server /usr/local/bin/
sudo cp src/redis-cli /usr/local/bin/
```

We can start the redis server now. It is very self explanatory command.

```bash
redis-server
```

Output:

```bash
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 6.0.5 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 18334
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'
```

Now open a new terminal and connect to ec2 server.
We can play with redis server

To test that Redis is functioning correctly, connect to the server using the command-line client:

Use the command **redis-cli** and than check the keys using **keys \*** command

```bash
[ec2-user@ip-172-31-2-38 ~]$ redis-cli
127.0.0.1:6379> keys *
(empty array)
```
Set a session id 1 to get the **Hello World!**

And now you can check the keys and you will see the session id 1

And use get command to see the output.

```bash 
127.0.0.1:6379> set session_id_1 'Hello World'
OK
127.0.0.1:6379> keys *
1) "session_id_1"
127.0.0.1:6379> get session_id_1
"Hello World"
127.0.0.1:6379>
```
We can also use **ping** command to check connectivity

```bash
redis-cli ping
```

Output

```bash
[ec2-user@ip-172-31-2-38 ~]$ redis-cli ping
PONG
```

Now we will make one last test to see it keeps the cached value. 

In the terminal where you tested redi-cli, exit.

```bash
127.0.0.1:6379> exit
```

Then Shutdown the redis server.

```bash
redis-cli shutdown
```

Check the other terminal to see the message.


But before using Redis on Production Stage we need to do some more steps. Configure the redis server IP, specify the port, arrange a database for backup etc.

```bash
18664:M 30 Jun 2020 19:08:29.270 # User requested shutdown...
18664:M 30 Jun 2020 19:08:29.270 * Saving the final RDB snapshot before exiting.
18664:M 30 Jun 2020 19:08:29.272 * DB saved on disk
18664:M 30 Jun 2020 19:08:29.272 # Redis is now ready to exit, bye bye...

```

Now restart the redis server 

```bash
redis-server
```

and open the other terminal and connect as client agin.

```bash
redis-cli
```

Check the keys. You will see the keys that you created before!

```bash
[ec2-user@ip-172-31-2-38 ~]$ redis-cli
127.0.0.1:6379> keys *
1) "test"
```
